COMPILER DCasm

	public CodeGenerator gen;
  
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  firstDigit = "0123".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  ident  = letter {letter | digit} ['.' letter {letter | digit}].
  number = digit {digit}.
  registerNum = "$" [firstDigit] digit.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab


PRODUCTIONS
/*------------------------------------------------------------------------*/
DCasm
= 
(
  "program" (. gen.Type = FileTypeEnum.Program; .)
  | "module" (. gen.Type = FileTypeEnum.Module; .)
) 
{ 
  "import" moduleName<out string name> 
  (.if(gen.Type == FileTypeEnum.Program) gen.ImportModule(name); else throw new ArgumentException("you cannot import a module into another"); .) 
}
block<out Block node> (. node.Children.ForEach(c => gen.RootNodes.Add(c)); .)
EOF.

BlockUnit<out INode exp>
=
(. exp = new Error(); .)
(
    arithm<out exp> 
    |
    immediateLoad<out exp>
    |
    data<out exp>
    |
    function<out exp>
    |
    Call<out exp>
    |
    Condition<out exp>
    |
    While<out exp>
)
.

block<out Block node> = 
(. node = new Block(); .)
"{"
BlockUnit<out INode exp> (. node.Children.Add(exp); .)
{ 
  BlockUnit<out INode exp2> (. node.Children.Add(exp2); .)
}
"}"
.



moduleName<out string name> = ident (. name = t.val; .).

register<out Register node> 
= registerNum (. node = new Register(); node.Value = t.val; .).

constant<out Const val>
= (. val = null; .)
(
  number (.val = new Const(t.val); .)
).


arithm<out INode exp>
= (. exp = new Error();.)
  (
    arithmOp<out string op> 
    register<out Register dest> 
    register<out Register src1> 
    (
      register<out Register src2> 
      (.exp = ArithmFactory.Create(op, dest, src1, src2); .)
      |
      constant<out Const src2> 
      (.exp = ArithmFactory.Create(op, dest, src1, src2); .)
    )
  )
.


immediateLoad<out INode exp>
= 
(. exp = new Error(); .)
(
  "li" (. exp = new ImmediateLoad(false); .)
  |
  "lui" (. exp = new ImmediateLoad(true); .)
)
register<out Register dest> constant<out Const val> (. exp.Children.Add(dest); exp.Children.Add(val); .)
.


arithmOp<out string op>
= (. op = "";.)
  ("add" | "sub" | "div" | "mul" ) (. op = t.val; .)
.


data<out INode exp>
=
(. exp = new Error(); .)
(
  "mov" register<out Register dest> register<out Register source> (. exp = new Move(source, dest); .)
  |
  "out" register<out Register OutputSelection> 
    (
      register<out Register val> (. exp = new Write(OutputSelection, val); .)
      | 
      constant<out Const val> (. exp = new Write(OutputSelection, val); .)
    ) 
  |
  "in" register<out Register inputSelection> register<out Register dest> (. exp = new Read(inputSelection, dest); .)
  |
  "lw" register<out Register dest> register<out Register baseReg> constant<out Const offset> (. exp = new Load(dest, baseReg, offset); .)
  |
  "sw" register<out Register value> register<out Register baseReg> constant<out Const offset> (. exp = new Store(baseReg, offset, value); .) 
)
.


function<out INode function>
=
"function" functionName<out string name>
(. function = new Function(name); .)
{
  (
    arithm<out INode exp> (. function.Children.Add(exp); .)
    |
    immediateLoad<out INode exp>   (. function.Children.Add(exp); .)
    |
    data<out INode exp>  (. function.Children.Add(exp); .)
    |
    Call<out INode exp>  (. function.Children.Add(exp); .)
    |
    Condition<out INode exp>  (. function.Children.Add(exp); .)
  )
}
"end" (. function.Value = name; gen.Functions.Add(name, function); .)
.

functionName<out string name> = ident (. name = t.val; .).

Call<out Call exp> = "call" functionName<out string name> (. exp = new Call(name); .).


Condition<out Condition node>
=
"if" 
register<out Register reg1> 
ConditionOp<out string op> 
register<out Register reg2>
"then" block<out Block thenblock> (. node = new Condition(reg1, op, reg2, thenblock); .)
["else" block<out Block elseBlock> (. node = new Condition(reg1, op, reg2, thenblock, elseBlock); .)]
.

ConditionOp<out string op> = (">" | "<" | "==" | ">=" | "<=") (. op = t.val; .).

While<out INode Node> 
=
"while" Condition<out Condition condition> Call<out INode exp>
(. Node = new While(exp, condition.Op); .)
.

END DCasm.