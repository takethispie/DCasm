COMPILER DCasm

	const int // types
	  undef = 0, integer = 1, boolean = 2, symbol = 3;

	const int // object kinds
	  var = 0, proc = 1;

    public CodeGenerator gen;
    public int adress = 0;
    public I_ISA CurrentISA;

/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  hexa = "ABCDEFabcdef0123456789".
  notQuote   = ANY - '"' - "\r\n".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  hex = "0x" hexa {hexa}.
  reg = "$" digit {digit}.
  ident  = letter {letter | digit}.
  number = digit {digit}.
  string   = '"' {notQuote} '"'.        // no check for valid escape sequences
  semicolon = ';'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

//------------------------------------------------------//
DCasm
= 
(ProcDecl | VarDecl) 
{ ProcDecl | VarDecl }
EOF.
//------------------------------------------------------//



/*------------------------------------------------------------------------*/
AddOp<out string op>
=                        (. op = "ADD"; .)
  ( '+'
  | '-'                  (. op = "SUB"; .)
  ).


/*------------------------------------------------------------------------*/
Expr<out int type>       (. int type1; string op; .)
= SimExpr<out type>
  [ RelOp<out op>
    SimExpr<out type1>   (. /*if (type != type1) SemErr("incompatible types"); type = boolean;*/ .)
  ].


/*------------------------------------------------------------------------*/
Factor<out int type, out string value>     (. int n; string name; .)
=                        (. type = undef; value = "";.)
  ( Ident<out name>      (. value = name; type = symbol;.)
  | number               (. value = t.val; type = integer; .)
  | '-' Factor<out type, out value> (. value = "-" + t.val; /*if (type != integer) { SemErr("integer type expected"); type = integer; }*/.)
  | "true"               (. value = t.val; type = boolean; .)
  | "false"              (. value = t.val; type = boolean; .)
  ).


/*------------------------------------------------------------------------*/
Ident<out string name> = ident  (. name = t.val; .).

/*------------------------------------------------------------------------*/
MulOp<out string op>
=                        (. op = "MUL"; .)
  ( '*'
  | '/'                  (. op = "DIV"; .)
  ).


/*------------------------------------------------------------------------*/
ProcDecl                 (. string name; int adr; .)
= "void"
  Ident<out name>        //create scope, if main set start adress
  '(' ')'
  '{'                    //enter scope
  { VarDecl | Stat }
  '}'.    

                                  //return, patch adress
/*------------------------------------------------------------------------*/
RelOp<out string op>
=                        (. op = "EQU"; .)
  ( "=="
  | '<'                  (. op = "LSS"; .)
  | '>'                  (. op = "GTR"; .)
  ).


/*------------------------------------------------------------------------*/
SimExpr<out int type>    	(. int type1; string op; .)
= Term<out type>
  { AddOp<out op>
    Term<out type1>      	(.  .) .)
	}.


/*------------------------------------------------------------------------*/
Stat                     	(. int type; string name; int adr, adr2, loopstart; .)
= Ident<out name>        	
  ( '='                  	(. /*if (obj.kind != var) SemErr("cannot assign to procedure");*/ .)
		SimExpr<out type> ';'
						   	(. /*if (type != obj.type) SemErr("incompatible types"); */ .)
	| '(' ')' ';'          	(. /*if (obj.kind != proc) SemErr("object is not a procedure"); gen.Emit(Op.CALL, obj.adr);*/ .)
	)

| "if" 
	'(' Expr<out type> ')' 	(. /*if (type != boolean) SemErr("boolean type expected");*/ .)
	Stat
	[ "else"               	
		Stat 
	]                      	//patch adress

| "while"                	//set loop start adress
	'(' Expr<out type> ')' 	(. /*if (type != boolean) SemErr("boolean type expected");*/.)
	Stat                   	//patch adress, jump to loopstart

| '{' { Stat | VarDecl } '}' .


/*------------------------------------------------------------------------*/
Term<out int type>       (. int type1; string op; string val1 = ""; string val2 = "";.)
= Factor<out type,out val1>	
  { MulOp<out op>
    Factor<out type1, out val2>    (. Term term = new Term(new Factor(val1,type),op,new Factor(val2,type)); .)
	}.


/*------------------------------------------------------------------------*/
Type<out int type>
=                        (. type = undef; .)
 ( "int"                 (. type = integer; .)
 | "bool"                (. type = boolean; .)
 ).


/*------------------------------------------------------------------------*/
VarDecl                  (. string name; int type; .)
= Type<out type>
  Ident<out name>        
  { ',' Ident<out name>  
  } ';'.


END DCasm.